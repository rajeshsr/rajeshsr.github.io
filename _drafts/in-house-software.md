---  
layout: post  
tags : [in-house-software, google]  
---  
{% include JB/setup %}  
  
The last post(https://plus.google.com/u/0/+rajeshsr/posts/fBWW1HyTzBR) I shared, talked about lots of "in-house innovation" Google has done and actually portrayed it as a crucial reason, for making Google what it's.   
  
When we use the word "in-house", it inevitably gets associated with another familiar term "re-inventing the wheel", which usually has a negative connotation. Only with passage of time and proof of success, does that wheel, really become an "innovation"! In some sense, "Guilty until proved otherwise" is at work here! :)  
  
Abstractly, why will u want to do something in-house? Why not follow the world? From my own limited experience and understanding, i can say it's done for the following reasons:  
  
1. More control. For instance, you get to optimize things for your workload. (Should we use that popular Relational DB for text search? Things aren't this obvious in the real world! :) ) Sometimes, this may entail new abstractions/paradigms altogether, in which case you have done some good innovation! Congratulations! :)  
  
2. Avoid bloat. Bloat can be defined as all those extra functions/features that comes packaged with your lib, which you may never care about in your life. This is an extremely important factor influencing "engineer's productivity": Simplify reasoning about the system as a whole. Well, every complex system, works by interacting with lots other sub-systems. And simplifying reasoning about the system, understanding data-flow etc. is extremely important to add features, track bugs, reason about performance etc. And bloats can easily distract us from the real problem, or even worse can cause a problem, when we don't even use that part of the code -- like a logging module which u use for a particular logging format, that has tools to searching it easier, failing because it can't find "sendmail" working, even though we don't use that feature. You can argue that, it's a bad module design. But things can be more subtle, in complex systems. Also, from system's performance viewpoint, bloat can be a huge problem.  
  
As a simple toy example, let us take the problem of computing digits of PI. Your program is just doing that, but as we know it will take ages before we break the world record. Apart from the "program-core" (defined as part of the code that does what you want to do and which you wrote), we may need a mechanism to monitor current state of the program, say, how many digit it has calculated, a string of last 100 digits, uptime etc. You can choose to make it "event-driven" or "periodic-dump" of the state. By periodic dump, i meant we may dump the "states that interests us" periodically into a file, say every 2 seconds, and u can look at that file to get the current state. By "event driven", you can expose some interface, say some network/http server, or even a shared memory which a client can read etc. For this, you can use an external server lib(say a httpserver lib). But you may need a lot of time to understand this new library, narrow down to the exact APIs u will need, reason about performance(ok, not very useful here, as it's not the core of the system), runtime requirements, configuration params etc. And before u know, u have spent more time doing that, than writing your program-core! :)  
How hard it's to write a simple httpserver, that serves only the state you need? It's a lot better than breaking your head about a new server, which is not even the focus of the program.  
Well, as a generalization, it may be tempting to conclude that, this argument just means: "Reinvent if it's not the focus of the problem.". But note that, the first example given, "Relational DB for text search" is a good example of why u may want to go "in-house/re-invent" for your "problem under focus".  
  
Well, there's an underlying dichotomy here:  
1. "Reinvent the wheel" makes sense because "using the new system" isn't worth it. That's "getting things done with reinventing (may be a measure of total time it takes to develop the product-core, ease of extensibility etc) > getting things done(same measure as before) with the new system".  I use the term "get things done" as a "accomplishing the objective" which as pointed out before can be: "measure of total time it takes to develop the product-core, ease of extensibility etc."  
  
2. "Using existing components" makes sense, if you know you don't get enough things done, because u wasted time hacking it. For instance, you don't hack up a filesystem, every time u write a code that reads/writes to a file. Or even an Operating System with all Linkers and Loaders for that matter, every time you write a Hello world code! :)  
  
It's all about the "objective function" u want to optimize: Speed of development, extensibility, performance etc. As a meta note, most design problems, or even general problems in life, seems hard to solve because nobody has clarified the "objective function" clearly. It's totally pointless to take part in a design discussion where "objective function" isn't clear! :)  
But the dichotomy is actually moved to another level: People can disagree on what's the right "objective function" to optimize. This is usually a more interesting and insightful discussion than the one where people are clueless about what they want! ;) And finally, everybody will refine their "objective function", to an awesome new level! :)  
  
Now, as far the idea of "do it the way the world does", let us see the arguments in favor of it:  
1. Lots of people in the wild have used the system. So it's less likely to be buggy, good enough documents about getting things started and getting common things done.  
This is a single most important reason, as far me! If you are launching a new product, you can't afford to suffer serious bugs! For instance, assume you decide to "show off" to the world, that you are calculating PI, and want to expose a HTTP server for the world to query the current state of computation. In that case, you may be better to use an existing server lib. For instance, there may be all sorts of malformed HTTP clients, which the "server in the wild", may be able to handle it well. Or even for a good performance under a burst heavy load (say you are Slashdotted, or to be a more modern, you are Reditted! ;) )  
Again, going back to our "objective function" model, do we really have to care about those "rare" people who have a malformed client? We are anyway just showing off, we don't care of some people can't access our system! (Well, calculating digits of PI already interests only a niche set of people! Who cares? :) ) Or may be, u really care about not missing those 1% of people with malformed clients? :P "Objective functions" can be very arbitrary, just choose what makes sense to you! (Can you see that, this arbitrariness, actually forces a meta-problem of "objective function" for "objective function", and can go on infinitely? :) )  
  
2. Very common tautological reasoning: The world uses it. Therefore, there must be something about it! Therefore, let us use it as well. Actually this argument isn't all that bad! For instance, you can reason that, it doesn't make sense to be a murderer/cheater because most of world is just not that! :P See, this reasoning works so well! ;)   
Again there's a flaw here. The big picture is tied to the "objective function" you want to optimize. The reason why that particular reasoning works for the case of "not being a murderer" is that, the "objective function", you want to optimize is harmony, equilibrium with the environment/society etc. It turns out that most people in the world happen to value that as an "objective" as well.  
  
But the objective, in the case of building an awesome system/product is, not equilibrium/harmony. You genuinely want to build something that changes the world. Change entails disturbance! And that's a strong reason to not "follow the world". Because most of world, by definition is just average! :) And you want to do something extraordinary. And rest assured, Extraordinary accomplishment warrants extraordinary measures!  
On the other hand, there's nothing wrong in choosing your objective to just exist/survive etc. This is very legitimate objective. And you should just follow the world, in this case.  
  
Well, i am a bit biased towards "in-house" philosophy! Simply because, the amount of productivity you get, working with such a system is enormous! You have an end-to-end view; knows the knobs to tweak; knows where to look for, and theorize correctly, in the wake of a bug/problem; no bloats implies no distractions etc.  
To me, open sourcing stuffs and all, is just about communicating a particular way of doing things to the world. You can say a paper/design_doc, will do just that. They definitely help to get some idea. But, I think code speaks volumes more information, than any well-written doc/paper: To know some important/interesting optimizations, more granular details of sub-systems/sub-modules. Half of complex system design, is about identifying important sub-systems and "drawing" the right boundaries among them, clarifying their interfaces, and of course gluing them together in a way that makes it easy to reason about etc. Fell free to disagree! :)  
  
In fact, i can try to refute the first claim that "External lib entails less damage" argument. I don't want to! I really believe it's a good reason! :)  
  
The fundamental premise behind that argument is that, the damage caused by bugs in systems, is "additive" in nature, or some other "nice" function. But most bugs, aren't that "good". A single bug on critical path, can bring down the system. There can lots of other bugs which may never get triggered, because it's a very rare code paths. Not all bugs are created equal, after all!   
If a bug in my "program-core" can affect the system, am not doing any good, by using that popular module in the wild, as opposed to write one of my own! :) As a generalization, you are just saying, any new line of code you add is a "door for new bug", so, don't write new code! :P  
  
Note the details of the argument carefully: Am not arguing "Why using lib from the wild world is bad". In fact, saying that, is refuting the fundamental principles of complex system design: Modularity. You assume, that a particular module does what it's supposed to do and glue it with your own! A sound module can make a system more reliable.  
Am making a case for a weaker claim here: "Why doing it on your own as opposed to using that "lib in the wild" may not be a bad idea." For instance, if you use a popular lib for some security feature, bug in it will get patched soon, but you may still have security bugs in your "program-core" which may compromise the system, so using "code from the wild" is no panacea.  
If you are not convinced, Awesome! :) Neither will I be, for such a weak argument! The point is, this particular weak case, combined with other strong advantages of going in-house, may make it a philosophy of choice.  
  
As in every discussions on competing philosophies, am going to say choose what makes sense to you. The point of this post, is to just clarify what goes into "what makes sense to you" part. Here is the guidelines i believe in:  
Choose an "objective" clearly, and see how "in-house" vs "world-way", affects your objective. For instance, "turn-around" time of your product/system is very important objective: How quickly can you get your system implemented? If you think, doing it "in-house" will take 1 year, but using something from the wild will take 1 month, then obviously don't do it in-house, at least for v1. Rest assured, you can keep optimizing a system in various ways! You will have plenty of time after v1. But keep the cost of bloat caused by all those feature which will never need and will never care in that lib in the wild. It will cripple reasoning, pace of adding new features, making you ridiculously unproductive! Often the idea of "wasted time doing it in-house" is a sign of cluelessness, inefficiency(mildly put over-engineering! Something to watch out for.), incompetence etc!  
So, just choose to err on "in-house" side, if you can know that it will not affect your objective! You will thank yourself forever! :)  
